<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>서울시 지하철역별 이용객 데이터</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://mapzen.com/js/mapzen.css">
  <style>
    html, body {
      width: 100%;
      height: 100%;
      padding: 0;
      margin: 0;
    }
    h4 {
      margin: 5px 0 5px 15px;
    }
    #map-30min {
      width: 100%;
      height: 100%;
    }
    .line {
      fill: none;
      stroke: rgb(255, 51, 51);
      stroke-width: 2px;
    }
    .lineToCompare {
      fill: none;
      stroke: rgb(255, 204, 0);
      stroke-width: 2px;
    }
    /*#popup {
      position: absolute;
      visibility: hidden;
      z-index: 1000;
      width: 200px;
      height: 200px;
      background-color: #eee;
    }*/
    #graph-box {
      position: absolute;
      width: 350px;
      height: 200px;
      bottom: 20px;
      left: 20px;
      padding: 10px 10px 10px 0;
      background-color: rgba(150, 150, 150, 0.9);
      z-index: 1000;
    }
    .info {
      background-color: #fff;
      padding: 3px;
    }
    .legend {
    line-height: 18px;
    color: #555;
    }
    .legend i {
        width: 18px;
        height: 18px;
        float: left;
        margin-right: 8px;
        opacity: 0.7;
    }
  </style>
</head>
<body>
  <div id="map-30min"></div>
  <script src="https://mapzen.com/js/mapzen.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.4.0/d3.js"></script>
  <script>
    // map
    var map = L.Mapzen.map('map-30min',{
      debugTangram: true,
      scene: './assets/detailed-scene.yaml',
      minZoom: 14,
      zoomControl: false,
      paddingTopLeft: [0, 300]
    });
    map.setView([37.5759,126.9768], 15);

    // add legend for isochrone data
    var legend = L.control({position: 'bottomright'});
    legend.onAdd = function (map) {

      var div = L.DomUtil.create('div', 'info legend'),
        grades = ['2015년 11, 12월 평균', '2016년'];
        colors = ['rgb(255, 204, 0)', 'rgb(255, 51, 51)'];
        // loop through our density intervals and generate a label with a colored square for each interval
        for (var i = 0; i < grades.length; i++) {
            div.innerHTML +=
                '<i style="background:' + colors[i] + '"></i> ' +
                grades[i] + '<br>';
        }

        return div;
    };

    legend.addTo(map);
    L.Mapzen.hash({
      map: map
    })

    map.on('tangramloaded', function(e) {

      var popup = document.createElement('div');
      popup.setAttribute('id', 'popup');
      map.getContainer().append(popup);

      var graphDiv = document.createElement('div');
      graphDiv.setAttribute('id','graph-box');
      map.getContainer().append(graphDiv);


      var scene = e.tangramLayer.scene;
      console.log(scene);

      // append graphs
      // map.getContainer().append()



      // feature edit popup
      map.getContainer().addEventListener('mousedown', function (event) {
        var picking = true;
        var latlng = map.mouseEventToLatLng(event);

        //var pixel = map.mouseEventToLayerPoint(event);
        var pixel = { x: event.clientX, y: event.clientY };

        scene.getFeatureAt(pixel).then(function(selection) {
          if(selection.feature) {

            if (selection.feature.source_name == 'stations') {
              graphDiv.innerHTML = '';
              drawSubGraph(selection.feature.properties);
              // popup.style.left = pixel.x + 'px';
              // popup.style.top = pixel.y + 'px';
              // popup.style.visibility = 'visible';
            } else {
              // popup.style.visibility = 'hidden';
            }
          } else {
            // popup.style.visibility = 'hidden';
          }

        });
      });
    });


    var drawSubGraph = function(properties) {
      var station_name = properties.station_name;
      var station_line = properties.line_num;
      var data = properties.dates;
      var dataToCompare = properties.previous_data;

      var margin = {top: 10, right: 20, bottom: 10, left: 55};
      // if (!document.querySelector('#line'+station_line)) {
      //   // Add a row for the line if there is not yet.
      //   d3.select('#graph-box')
      //               .append('div')
      //               .attr('id', 'line'+station_line)
      //               .append('div')
      //               .append('h2')
      //               .html(station_line+'호선')
      // }
      var parseTime = d3.timeParse('%Y%m%d');
      var getDateString = function(ds) {
        var date = parseTime(ds);
        return date;
      }




      var aveExit = 0;
      var aveEntry = 0;
      dataToCompare.forEach(function(d) {
        aveExit += d.turnstile_data[0].exits;
        aveEntry += d.turnstile_data[0].entries;
      })
      aveExit /= dataToCompare.length;
      aveEntry /= dataToCompare.length;

      var reformedDataToCompare = [];

      var dates = [];
      data.reverse();
      data.forEach(function(d) {
        d.date = getDateString(d.date);
        dates.push(getDateString(d.date));
        reformedDataToCompare.push({
          date: d.date,
          turnstile_data: [{
            entries: aveEntry,
            exits: aveExit
          }]
        })
      });

      var formatTime = d3.timeFormat('%m월%d일');

      var subDiv = d3.select('#graph-box')
                      .append('div')
                  .attr('class', 'sub-graph col-md-6 col-xs-12');

      var subDivWidth = document.getElementById('graph-box').clientWidth - 30;
      var subHeight = document.getElementById('graph-box').clientHeight - 80;


      subDiv.append('h4')
            .text(station_name);

      var subSvg = subDiv
                    .append('svg')
                    .attr('width', subDivWidth + margin.left +margin.right)
                    .attr('height', subHeight + margin.top + margin.bottom)
                    .append('g')
                    .attr('transform',
                          'translate(' + margin.left + ',' + margin.top + ')');

      var subX = d3.scaleTime().range([0, subDivWidth- margin.left]);
      var subY = d3.scaleLinear().range([subHeight, 0]);


      // define the line
      var subValueline = d3.line()
          .x(function(d) { return subX(d.date); })
          .y(function(d) { return subY(d.turnstile_data[0].exits); });
      //

      var lineToCompare = d3.line()
          .x(function(d) { return subX(d.date);})
          .y(function(d) { return subY(d.aveValue);})
      // var subEntryValueline = d3.line()
      //     .x(function(d) { return subX(d.date); })
      //     .y(function(d) { return subY(d.turnstile_data[0].entries); });


      var subMin = Math.min(d3.min(data, function(d) { return d.turnstile_data[0].exits; }), d3.min(reformedDataToCompare, function(d) { return d.turnstile_data[0].exits }));
      var subMax = Math.max(d3.max(data, function(d) { return d.turnstile_data[0].exits; }), d3.max(reformedDataToCompare, function(d) { return d.turnstile_data[0].exits}));

      var middle = (subMin + subMax)/2;

      subX.domain(d3.extent(data, function(d) { return d.date; }));
      subY.domain([subMin*0.9, subMax*1.1]);


      // Add the entry valueline path.
      // subSvg.append('path')
      //     .data([data])
      //     .attr('class', 'line'+station_line+ ' entry')
      //     .attr('d', subEntryValueline);


      // Add the valueline path.
      subSvg.append('path')
          .data([data])
          .attr('class', 'line')
          .attr('d', subValueline);


      subSvg.append('path')
          .data([reformedDataToCompare])
          .attr('class', 'lineToCompare')
          .attr('d', subValueline);

      subSvg.append('g')
          .attr('transform', 'translate(0,' + (subHeight) + ')')
          .call(d3.axisBottom(subX).tickValues(dates).tickFormat(function(d, i) {
            if ( i%2 ==0) {
              return formatTime(d);
            }
            else return '';}))

      subSvg.append('g')
          .call(d3.axisLeft(subY).tickValues([subMin, middle, subMax]));

      // Add Scatter plot points and tooltip
      subSvg.selectAll('dot')
          .data(data)
          .enter().append('svg:image')
          .attr('width', 6)
          .attr('height', 6)
          .attr('xlink:href','./assets/dot.png')
          .attr('x', function(d, i) {
            return subX(d.date)-3})
          .attr('y', function(d, i) {
            return subY(d.turnstile_data[0].exits)-3})
        // .on('click',function(d) {
        //   div.transition()
        //       .duration(200)
        //       .style('opacity', .9);
        //   div .html(formatTime(d.date) + '<br/>'  + d3.format(',')(d.turnstile[0].exits))
        //       .style('left', (d3.event.pageX - 40) + 'px')
        //       .style('top', (d3.event.pageY - 35) + 'px');
        // })
        // .on('mouseover', function(d) {
        //   div.transition()
        //       .duration(200)
        //       .style('opacity', .9);
        //   div .html(formatTime(d.date) + '<br/>'  + d3.format(',')(d.turnstile[0].exits))
        //       .style('left', (d3.event.pageX) + 'px')
        //       .style('top', (d3.event.pageY - 28) + 'px');
        // })
        // .on('mouseout', function(d) {
        //     div.transition()
        //         .duration(500)
        //         .style('opacity', 0);
        // });

    }

  </script>
</body>
</html>
